/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    AppConcept: ClassViewer<'AppConcept', "app_name" | "app_subtitle" | "app_description" | "app_category" | "colors" | "typography" | "effects" | "style_description" | "app_icon_prompt" | "cover_image_prompt">;
    
    AppConceptsOutput: ClassViewer<'AppConceptsOutput', "concepts">;
    
    AppScreenPromptsOutput: ClassViewer<'AppScreenPromptsOutput', "app_screen_prompts">;
    
    AppStructure: ClassViewer<'AppStructure', "tabs" | "common_layout_elements" | "screens">;
    
    CoverImagePrompt: ClassViewer<'CoverImagePrompt', "image_prompt" | "style_notes">;
    
    CoverVideoPrompt: ClassViewer<'CoverVideoPrompt', "video_prompt">;
    
    DemoAppOutput: ClassViewer<'DemoAppOutput', "app_name" | "app_subtitle" | "app_description" | "app_category" | "app_icon_prompt" | "style_guide">;
    
    ImprovedDescriptionOutput: ClassViewer<'ImprovedDescriptionOutput', "improved_description" | "improved_style" | "inferred_category">;
    
    ModelTestResponse: ClassViewer<'ModelTestResponse', "model_name" | "response_text" | "character_count" | "passed">;
    
    ScreenDetail: ClassViewer<'ScreenDetail', "screen_name" | "purpose" | "layout_type" | "unique_elements" | "active_tab_index">;
    
    ScreenImagePrompt: ClassViewer<'ScreenImagePrompt', "canvas_edit_prompt">;
    
    StyleColors: ClassViewer<'StyleColors', "primary" | "background" | "text" | "accent">;
    
    StyleEffects: ClassViewer<'StyleEffects', "cornerRadius" | "shadowStyle" | "designPhilosophy">;
    
    StyleTypography: ClassViewer<'StyleTypography', "headlineFont" | "headlineSize" | "headlineWeight" | "bodyFont" | "bodySize" | "bodyWeight">;
    
    TabStructure: ClassViewer<'TabStructure', "has_tabs" | "tab_names" | "tab_icon_descriptions" | "active_tab_color" | "inactive_tab_color" | "active_icon_style" | "inactive_icon_style" | "selection_indicator" | "tab_bar_height" | "icon_size" | "label_size">;
    
    VisionTestResponse: ClassViewer<'VisionTestResponse', "model_name" | "can_see_image" | "description" | "object_count">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "AppConcept","AppConceptsOutput","AppScreenPromptsOutput","AppStructure","CoverImagePrompt","CoverVideoPrompt","DemoAppOutput","ImprovedDescriptionOutput","ModelTestResponse","ScreenDetail","ScreenImagePrompt","StyleColors","StyleEffects","StyleTypography","TabStructure","VisionTestResponse",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.AppConcept = this.tb.classViewer("AppConcept", [
          "app_name","app_subtitle","app_description","app_category","colors","typography","effects","style_description","app_icon_prompt","cover_image_prompt",
        ]);
        
        this.AppConceptsOutput = this.tb.classViewer("AppConceptsOutput", [
          "concepts",
        ]);
        
        this.AppScreenPromptsOutput = this.tb.classViewer("AppScreenPromptsOutput", [
          "app_screen_prompts",
        ]);
        
        this.AppStructure = this.tb.classViewer("AppStructure", [
          "tabs","common_layout_elements","screens",
        ]);
        
        this.CoverImagePrompt = this.tb.classViewer("CoverImagePrompt", [
          "image_prompt","style_notes",
        ]);
        
        this.CoverVideoPrompt = this.tb.classViewer("CoverVideoPrompt", [
          "video_prompt",
        ]);
        
        this.DemoAppOutput = this.tb.classViewer("DemoAppOutput", [
          "app_name","app_subtitle","app_description","app_category","app_icon_prompt","style_guide",
        ]);
        
        this.ImprovedDescriptionOutput = this.tb.classViewer("ImprovedDescriptionOutput", [
          "improved_description","improved_style","inferred_category",
        ]);
        
        this.ModelTestResponse = this.tb.classViewer("ModelTestResponse", [
          "model_name","response_text","character_count","passed",
        ]);
        
        this.ScreenDetail = this.tb.classViewer("ScreenDetail", [
          "screen_name","purpose","layout_type","unique_elements","active_tab_index",
        ]);
        
        this.ScreenImagePrompt = this.tb.classViewer("ScreenImagePrompt", [
          "canvas_edit_prompt",
        ]);
        
        this.StyleColors = this.tb.classViewer("StyleColors", [
          "primary","background","text","accent",
        ]);
        
        this.StyleEffects = this.tb.classViewer("StyleEffects", [
          "cornerRadius","shadowStyle","designPhilosophy",
        ]);
        
        this.StyleTypography = this.tb.classViewer("StyleTypography", [
          "headlineFont","headlineSize","headlineWeight","bodyFont","bodySize","bodyWeight",
        ]);
        
        this.TabStructure = this.tb.classViewer("TabStructure", [
          "has_tabs","tab_names","tab_icon_descriptions","active_tab_color","inactive_tab_color","active_icon_style","inactive_icon_style","selection_indicator","tab_bar_height","icon_size","label_size",
        ]);
        
        this.VisionTestResponse = this.tb.classViewer("VisionTestResponse", [
          "model_name","can_see_image","description","object_count",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}