/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    Avatar: ClassViewer<'Avatar', "summary" | "apparent_age" | "gender_presentation" | "face_shape" | "face_width" | "jawline" | "cheekbones" | "chin_shape" | "skin_tone" | "skin_undertone" | "complexion_details" | "hair_color" | "hair_color_variation" | "hair_length" | "hair_style" | "hair_texture" | "hair_volume" | "hairline_shape" | "hair_parting" | "eye_color" | "eye_shape" | "eye_size" | "eye_spacing" | "eyelash_visibility" | "eyebrow_shape" | "eyebrow_thickness" | "eyebrow_color" | "nose_shape" | "nose_bridge" | "nose_tip" | "nose_width" | "nostril_visibility" | "lip_shape" | "upper_lip_fullness" | "lower_lip_fullness" | "mouth_width" | "cupids_bow" | "facial_hair_type" | "facial_hair_style" | "facial_hair_density" | "facial_hair_color" | "glasses" | "glasses_style" | "glasses_frame_color" | "glasses_lens_type" | "freckles" | "freckle_intensity" | "beauty_marks" | "dimples" | "ear_size" | "ear_prominence" | "piercings" | "confidence" | "avatar_style" | "key_features">;
    
    BasicResponse: ClassViewer<'BasicResponse', "answer" | "confidence">;
    
    DetailedResponse: ClassViewer<'DetailedResponse', "answer" | "confidence" | "explanation" | "sources">;
    
    Scene: ClassViewer<'Scene', "main_description" | "character_in_scene" | "character_placement" | "camera_angle" | "shot_type" | "setting" | "background" | "time_of_day" | "mood" | "color_palette" | "lighting_style" | "style_keywords" | "quality_markers" | "flux_prompt" | "negative_prompt" | "flux_guidance_scale" | "flux_steps" | "complexity_score" | "avatar_integration" | "key_elements">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "Avatar","BasicResponse","DetailedResponse","Scene",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.Avatar = this.tb.classViewer("Avatar", [
          "summary","apparent_age","gender_presentation","face_shape","face_width","jawline","cheekbones","chin_shape","skin_tone","skin_undertone","complexion_details","hair_color","hair_color_variation","hair_length","hair_style","hair_texture","hair_volume","hairline_shape","hair_parting","eye_color","eye_shape","eye_size","eye_spacing","eyelash_visibility","eyebrow_shape","eyebrow_thickness","eyebrow_color","nose_shape","nose_bridge","nose_tip","nose_width","nostril_visibility","lip_shape","upper_lip_fullness","lower_lip_fullness","mouth_width","cupids_bow","facial_hair_type","facial_hair_style","facial_hair_density","facial_hair_color","glasses","glasses_style","glasses_frame_color","glasses_lens_type","freckles","freckle_intensity","beauty_marks","dimples","ear_size","ear_prominence","piercings","confidence","avatar_style","key_features",
        ]);
        
        this.BasicResponse = this.tb.classViewer("BasicResponse", [
          "answer","confidence",
        ]);
        
        this.DetailedResponse = this.tb.classViewer("DetailedResponse", [
          "answer","confidence","explanation","sources",
        ]);
        
        this.Scene = this.tb.classViewer("Scene", [
          "main_description","character_in_scene","character_placement","camera_angle","shot_type","setting","background","time_of_day","mood","color_palette","lighting_style","style_keywords","quality_markers","flux_prompt","negative_prompt","flux_guidance_scale","flux_steps","complexity_score","avatar_integration","key_elements",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}