---
description: 
globs: convex/**
alwaysApply: false
---
---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx
---

# Convex guidelines

> **📦 Next.js Integration:** For deployment, build configuration, and Next.js-specific patterns with Convex, see [convex-nextjs-rules.mdc](./convex-nextjs-rules.mdc)

## Function guidelines
### New function syntax
- ALWAYS use the new function syntax for Convex functions. For example:
      ```typescript
      import { query } from "./_generated/server";
      import { v } from "convex/values";
      export const f = query({
          args: {},
          returns: v.null(),
          handler: async (ctx, args) => {
          // Function body
          },
      });
      ```

### Http endpoint syntax
- HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator. For example:
      ```typescript
      import { httpRouter } from "convex/server";
      import { httpAction } from "./_generated/server";
      const http = httpRouter();
      http.route({
          path: "/echo",
          method: "POST",
          handler: httpAction(async (ctx, req) => {
          const body = await req.bytes();
          return new Response(body, { status: 200 });
          }),
      });
      ```
- HTTP endpoints are always registered at the exact path you specify in the `path` field. For example, if you specify `/api/someRoute`, the endpoint will be registered at `/api/someRoute`.

### Validators
- Below is an example of an array validator:
                            ```typescript
                            import { mutation } from "./_generated/server";
                            import { v } from "convex/values";

                            export default mutation({
                            args: {
                                simpleArray: v.array(v.union(v.string(), v.number())),
                            },
                            handler: async (ctx, args) => {
                                //...
                            },
                            });
                            ```
- Below is an example of a schema with validators that codify a discriminated union type:
                            ```typescript
                            import { defineSchema, defineTable } from "convex/server";
                            import { v } from "convex/values";

                            export default defineSchema({
                                results: defineTable(
                                    v.union(
                                        v.object({
                                            kind: v.literal("error"),
                                            errorMessage: v.string(),
                                        }),
                                        v.object({
                                            kind: v.literal("success"),
                                            value: v.number(),
                                        }),
                                    ),
                                )
                            });
                            ```
- Always use the `v.null()` validator when returning a null value. Below is an example query that returns a null value:
                                  ```typescript
                                  import { query } from "./_generated/server";
                                  import { v } from "convex/values";

                                  export const exampleQuery = query({
                                    args: {},
                                    returns: v.null(),
                                    handler: async (ctx, args) => {
                                        console.log("This query returns a null value");
                                        return null;
                                    },
                                  });
                                  ```
- Here are the valid Convex types along with their respective validators:
 Convex Type  | TS/JS type  |  Example Usage         | Validator for argument validation and schemas  | Notes                                                                                                                                                                                                 |
| ----------- | ------------| -----------------------| -----------------------------------------------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Id          | string      | `doc._id`              | `v.id(tableName)`                              |                                                                                                                                                                                                       |
| Null        | null        | `null`                 | `v.null()`                                     | JavaScript's `undefined` is not a valid Convex value. Functions the return `undefined` or do not return will return `null` when called from a client. Use `null` instead.                             |
| Int64       | bigint      | `3n`                   | `v.int64()`                                    | Int64s only support BigInts between -2^63 and 2^63-1. Convex supports `bigint`s in most modern browsers.                                                                                              |
| Float64     | number      | `3.1`                  | `v.number()`                                   | Convex supports all IEEE-754 double-precision floating point numbers (such as NaNs). Inf and NaN are JSON serialized as strings.                                                                      |
| Boolean     | boolean     | `true`                 | `v.boolean()`                                  |
| String      | string      | `"abc"`                | `v.string()`                                   | Strings are stored as UTF-8 and must be valid Unicode sequences. Strings must be smaller than the 1MB total size limit when encoded as UTF-8.                                                         |
| Bytes       | ArrayBuffer | `new ArrayBuffer(8)`   | `v.bytes()`                                    | Convex supports first class bytestrings, passed in as `ArrayBuffer`s. Bytestrings must be smaller than the 1MB total size limit for Convex types.                                                     |
| Array       | Array]      | `[1, 3.2, "abc"]`      | `v.array(values)`                              | Arrays can have at most 8192 values.                                                                                                                                                                  |
| Object      | Object      | `{a: "abc"}`           | `v.object({property: value})`                  | Convex only supports "plain old JavaScript objects" (objects that do not have a custom prototype). Objects can have at most 1024 entries. Field names must be nonempty and not start with "$" or "_". |
| Record      | Record      | `{"a": "1", "b": "2"}` | `v.record(keys, values)`                       | Records are objects at runtime, but can have dynamic keys. Keys must be only ASCII characters, nonempty, and not start with "$" or "_".                                                               |

### Function registration
- Use `internalQuery`, `internalMutation`, and `internalAction` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from `./_generated/server`.
- Use `query`, `mutation`, and `action` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use `query`, `mutation`, or `action` to register sensitive internal functions that should be kept private.
- You CANNOT register a function through the `api` or `internal` objects.
- ALWAYS include argument and return validators for all Convex functions. This includes all of `query`, `internalQuery`, `mutation`, `internalMutation`, `action`, and `internalAction`. If a function doesn't return anything, include `returns: v.null()` as its output validator.
- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns `null`.

### Function calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action.
- Use `ctx.runMutation` to call a mutation from a mutation or action.
- Use `ctx.runAction` to call an action from an action.
- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.
- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.
- All of these calls take in a `FunctionReference`. Do NOT try to pass the callee function directly into one of these calls.
- When using `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,
                            ```
                            export const f = query({
                              args: { name: v.string() },
                              returns: v.string(),
                              handler: async (ctx, args) => {
                                return "Hello " + args.name;
                              },
                            });

                            export const g = query({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
                                return null;
                              },
                            });
                            ```

### Function references
- Function references are pointers to registered Convex functions.
- Use the `api` object defined by the framework in `convex/_generated/api.ts` to call public functions registered with `query`, `mutation`, or `action`.
- Use the `internal` object defined by the framework in `convex/_generated/api.ts` to call internal (or private) functions registered with `internalQuery`, `internalMutation`, or `internalAction`.
- Convex uses file-based routing, so a public function defined in `convex/example.ts` named `f` has a function reference of `api.example.f`.
- A private function defined in `convex/example.ts` named `g` has a function reference of `internal.example.g`.
- Functions can also registered within directories nested within the `convex/` folder. For example, a public function `h` defined in `convex/messages/access.ts` has a function reference of `api.messages.access.h`.

### Api design
- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the `convex/` directory.
- Use `query`, `mutation`, and `action` to define public functions.
- Use `internalQuery`, `internalMutation`, and `internalAction` to define private, internal functions.

### Pagination
- Paginated queries are queries that return a list of results in incremental pages.
- You can define pagination using the following syntax:

                            ```ts
                            import { v } from "convex/values";
                            import { query, mutation } from "./_generated/server";
                            import { paginationOptsValidator } from "convex/server";
                            export const listWithExtraArg = query({
                                args: { paginationOpts: paginationOptsValidator, author: v.string() },
                                handler: async (ctx, args) => {
                                    return await ctx.db
                                    .query("messages")
                                    .filter((q) => q.eq(q.field("author"), args.author))
                                    .order("desc")
                                    .paginate(args.paginationOpts);
                                },
                            });
                            ```
                            Note: `paginationOpts` is an object with the following properties:
                            - `numItems`: the maximum number of documents to return (the validator is `v.number()`)
                            - `cursor`: the cursor to use to fetch the next page of documents (the validator is `v.union(v.string(), v.null())`)
- A query that ends in `.paginate()` returns an object that has the following properties:
                            - page (contains an array of documents that you fetches)
                            - isDone (a boolean that represents whether or not this is the last page of documents)
                            - continueCursor (a string that represents the cursor to use to fetch the next page of documents)


## Validator guidelines
- `v.bigint()` is deprecated for representing signed 64-bit integers. Use `v.int64()` instead.
- Use `v.record()` for defining a record type. `v.map()` and `v.set()` are not supported.

## Project structure guidelines
- The `convex/_generated/` folder contains auto-generated TypeScript definitions and should be added to `.gitignore`.
- Generated files include `api.d.ts`, `api.js`, `dataModel.d.ts`, `server.d.ts`, and `server.js`.
- These files are automatically regenerated by Convex based on your schema and function definitions.
- If you need to remove them from git tracking: `git rm -r --cached convex/_generated`

### Import path guidelines
- **ALWAYS** use TypeScript path aliases instead of relative imports for Convex imports
- Use `@convex/_generated/api` instead of relative paths like `../../convex/_generated/api`
- Use `@convex/_generated/dataModel` instead of relative paths like `../../convex/_generated/dataModel`
- This prevents import breakage when moving files to different directory depths
- Configure the `@convex/*` path alias in your `tsconfig.json`:
  ```json
  {
    "compilerOptions": {
      "paths": {
        "@convex/*": ["./convex/*"]
      }
    }
  }
  ```

**Example:**
```typescript
// ❌ Bad - breaks when file moves to different depth
import { api } from '../../convex/_generated/api';
import { Id } from '../../convex/_generated/dataModel';

// ✅ Good - always works regardless of file location
import { api } from '@convex/_generated/api';
import { Id } from '@convex/_generated/dataModel';
```

## Schema guidelines
- Always define your schema in `convex/schema.ts`.
- Always import the schema definition functions from `convex/server`:
- System fields are automatically added to all documents and are prefixed with an underscore. The two system fields that are automatically added to all documents are `_creationTime` which has the validator `v.number()` and `_id` which has the validator `v.id(tableName)`.
- Always include all index fields in the index name. For example, if an index is defined as `["field1", "field2"]`, the index name should be "by_field1_and_field2".
- Index fields must be queried in the same order they are defined. If you want to be able to query by "field1" then "field2" and by "field2" then "field1", you must create separate indexes.

## Typescript guidelines
### Avoiding `any` type issues
- Let TypeScript infer types from Convex queries - do NOT explicitly type query results:
  ```typescript
  // ❌ Bad - explicit any
  const people = await ctx.db.query("people").collect();
  people.map((p: any) => p.name);
  
  // ✅ Good - TypeScript infers Doc<"people">
  const people = await ctx.db.query("people").collect();
  people.map((p) => p.name); // p is automatically typed correctly
  ```
- Do NOT type index callback parameters:
  ```typescript
  // ❌ Bad
  .withIndex("by_user", (q: any) => q.eq("userId", userId))
  
  // ✅ Good - TypeScript infers the query builder type
  .withIndex("by_user", (q) => q.eq("userId", userId))
  ```
- Use `Doc<TableName>` type from `_generated/dataModel` when you need explicit typing:
  ```typescript
  import { Doc } from "./_generated/dataModel";
  
  // When you need to explicitly type a parameter
  const processUser = (user: Doc<"users">) => {
    // user is properly typed with all fields from the users table
  };
  ```

### Type imports and usage
- You can use the helper typescript type `Id` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use `Id<'users'>` to get the type of the id for that table.
- If you need to define a `Record` make sure that you correctly provide the type of the key and value in the type. For example a validator `v.record(v.id('users'), v.string())` would have the type `Record<Id<'users'>, string>`. Below is an example of using `Record` with an `Id` type in a query:
                    ```ts
                    import { query } from "./_generated/server";
                    import { Doc, Id } from "./_generated/dataModel";

                    export const exampleQuery = query({
                        args: { userIds: v.array(v.id("users")) },
                        returns: v.record(v.id("users"), v.string()),
                        handler: async (ctx, args) => {
                            const idToUsername: Record<Id<"users">, string> = {};
                            for (const userId of args.userIds) {
                                const user = await ctx.db.get(userId);
                                if (user) {
                                    users[user._id] = user.username;
                                }
                            }

                            return idToUsername;
                        },
                    });
                    ```
- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in `Id<'users'>` rather than `string`.
- Always use `as const` for string literals in discriminated union types.
- When using the `Array` type, make sure to always define your arrays as `const array: Array<T> = [...];`
- When using the `Record` type, make sure to always define your records as `const record: Record<KeyType, ValueType> = {...};`
- Always add `@types/node` to your `package.json` when using any Node.js built-in modules.

## Full text search guidelines
- A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);

## Query guidelines
- Do NOT use `filter` in queries. Instead, define an index in the schema and use `withIndex` instead.
- Convex queries do NOT support `.delete()`. Instead, `.collect()` the results, iterate over them, and call `ctx.db.delete(row._id)` on each result.
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, don't use `.collect()` or `.take(n)` on the result of a query. Instead, use the `for await (const row of query)` syntax.
### Ordering
- By default Convex always returns documents in ascending `_creationTime` order.
- You can use `.order('asc')` or `.order('desc')` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.
- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.


## Mutation guidelines
- Use `ctx.db.replace` to fully replace an existing document. This method will throw an error if the document does not exist.
- Use `ctx.db.patch` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.

## Action guidelines
- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.db` inside of an action. Actions don't have access to the database.
- Below is an example of the syntax for an action:
                    ```ts
                    import { action } from "./_generated/server";

                    export const exampleAction = action({
                        args: {},
                        returns: v.null(),
                        handler: async (ctx, args) => {
                            console.log("This action does not return anything");
                            return null;
                        },
                    });
                    ```

### Internal/Public Action Pattern
- Use internal actions with optional `profileId` for maximum reusability
- Create public action wrappers that handle authentication and call internal actions
- This pattern enables calling from both authenticated clients and other Convex functions (jobs, webhooks, crons)

**Example Pattern:**
```typescript
// Internal action - reusable, no auth, optional profileId
export const processDataInternal = internalAction({
  args: {
    profileId: v.optional(v.id("profiles")),
    data: v.string(),
  },
  returns: v.id("results"),
  handler: async (ctx, args) => {
    // Business logic here
    if (!args.profileId) {
      throw new Error("profileId required");
    }

    // Process data and create result
    const resultId = await ctx.runMutation(internal.results.create, {
      profileId: args.profileId,
      data: args.data,
    });

    return resultId;
  },
});

// Public action - handles auth, calls internal action
export const processData = action({
  args: {
    data: v.string(),
  },
  returns: v.id("results"),
  handler: async (ctx, args) => {
    // Get authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user's profile
    const profile = await ctx.runQuery(api.profiles.getCurrentProfile);
    if (!profile) {
      throw new Error("Profile not found");
    }

    // Call internal action with profileId
    return await ctx.runAction(internal.myModule.processDataInternal, {
      profileId: profile._id,
      data: args.data,
    });
  },
});
```

**Benefits:**
- **Separation of concerns**: Auth logic separated from business logic
- **Reusability**: Internal action can be called from crons, jobs, webhooks, or other actions
- **Testability**: Business logic can be tested without auth mocking
- **Flexibility**: Optional profileId allows both authenticated and system-initiated calls

**Use cases:**
- Background job processes data for a user (pass profileId from job queue)
- Cron task generates reports for all users (iterate and call internal action)
- Webhook receives data and needs to process it for a specific user
- Client action needs same processing with auth validation

## Testing with Convex CLI

### Running functions with npx convex run
- Test queries, mutations, and actions directly from the CLI
- Pass arguments as JSON-formatted strings
- Use `--identity` flag to simulate authenticated users
- View all available options with `npx convex run --help`

**Basic usage:**
```bash
# Run a query or mutation
npx convex run myModule:myFunction '{"arg1": "value1", "arg2": 123}'

# Run without arguments
npx convex run myModule:simpleFunction '{}'
```

**Testing authenticated actions with --identity:**
```bash
# Simulate a user with identity
npx convex run myActions:publicAction \
  '{"data": "test"}' \
  --identity '{"subject":"user_123","name":"Test User","email":"test@example.com"}'

# The identity object can include any fields your auth system uses
# Common fields: subject (required), name, email, tokenIdentifier, etc.
```

**Testing internal actions (recommended for development):**
```bash
# Internal actions bypass authentication - no --identity needed
npx convex run myActions:internalAction \
  '{"profileId":"j57d8p1xcgqafkggamgvnbea0s7qvp64","data":"test"}'

# This is why the Internal/Public Action Pattern is valuable for testing
```

**Other useful CLI flags:**
```bash
# Watch a query for changes
npx convex run myModule:myQuery '{}' --watch

# Push code before running
npx convex run myModule:myFunction '{}' --push

# Use a specific environment file
npx convex run myModule:myFunction '{}' --env-file .env.production
```

### Best practices for CLI testing
- **Use internal actions with optional profileId** for easier testing without auth mocking
- **Test public actions with --identity** to verify auth logic works correctly
- **Keep test data in separate functions** - create test helper functions for seeding data
- **Use --watch with queries** to see real-time updates during development
- **Combine with --push** to test latest code changes immediately

### Example: Testing a complete flow
```bash
# 1. Create test data with internal action (no auth needed)
npx convex run demoActions:generateDemoAppInternal \
  '{"appDescriptionInput":"Test app","profileId":"j57..."}'

# 2. Test public action with authentication
npx convex run demoActions:generateDemoAppFromDescription \
  '{"appDescription":"Test app"}' \
  --identity '{"subject":"user_123","name":"Test User"}'

# 3. Query results and watch for changes
npx convex run apps:getApp '{"appId":"j97..."}' --watch
```

## Scheduling guidelines
### Cron Jobs (Scheduled Functions)

Convex provides built-in **scheduled functions** (cron jobs) that run automatically on Convex's infrastructure without requiring additional deployment or server management.

#### **How Cron Jobs Work**
- **Defined in `convex/crons.ts`** - A special file that exports cron configurations
- **Run on Convex servers** - Automatically executed by Convex's infrastructure
- **No deployment needed** - Just push your code and crons are registered
- **Monitor in dashboard** - View and track execution in Convex Dashboard → Scheduled Functions
- **Two scheduling methods**:
  - `crons.interval()` - Run every X minutes/hours/days
  - `crons.cron()` - Use cron syntax (e.g., "0 0 * * *" for daily at midnight)

#### **Basic Structure**
```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Define your cron schedules here...

export default crons;
```

#### **Using `crons.interval()` - Time-based scheduling**
```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Run every 5 minutes
crons.interval(
  "cleanup old sessions",
  { minutes: 5 },
  internal.sessions.cleanupExpired
);

// Run every 2 hours
crons.interval(
  "sync external data",
  { hours: 2 },
  internal.sync.syncData
);

// Run every day (24 hours)
crons.interval(
  "daily report",
  { hours: 24 },
  internal.reports.generateDaily
);

export default crons;
```

#### **Using `crons.cron()` - Cron syntax for precise timing**
```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Daily at 3:00 AM
crons.cron(
  "daily cleanup",
  "0 3 * * *",
  internal.cleanup.runDaily
);

// Every Monday at 9:00 AM
crons.cron(
  "weekly report",
  "0 9 * * 1",
  internal.reports.generateWeekly
);

// First day of month at midnight
crons.cron(
  "monthly billing",
  "0 0 1 * *",
  internal.billing.processMonthly
);

// Every 15 minutes
crons.cron(
  "health check",
  "*/15 * * * *",
  internal.monitoring.healthCheck
);

export default crons;
```

#### **Cron Syntax Reference**
```
┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of month (1 - 31)
│ │ │ ┌───────────── month (1 - 12)
│ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday)
│ │ │ │ │
* * * * *

Examples:
"0 0 * * *"   - Daily at midnight
"0 9 * * 1"   - Every Monday at 9 AM
"*/30 * * * *" - Every 30 minutes
"0 0 1 * *"   - First day of month at midnight
"0 */6 * * *" - Every 6 hours
```

#### **Complete Example with Documentation**
```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

/**
 * Convex Cron Jobs
 * 
 * Scheduled functions that run automatically on Convex's infrastructure.
 * View and monitor in Convex Dashboard → Scheduled Functions
 */

const crons = cronJobs();

/**
 * Fail stuck generation jobs (every 5 minutes)
 * 
 * Automatically marks jobs as "failed" if they've been generating for >6 minutes.
 * Prevents UI from showing perpetual "generating" state when external APIs hang.
 */
crons.interval(
  "fail stuck generation jobs",
  { minutes: 5 },
  internal.generationJobs.failStuckJobs
);

/**
 * Clean up old completed jobs (daily at 3 AM)
 * 
 * Deletes completed/failed jobs older than 24 hours to prevent
 * table bloat and maintain query performance.
 */
crons.cron(
  "cleanup old generation jobs",
  "0 3 * * *",
  internal.generationJobs.cleanupCompletedJobs
);

/**
 * Send weekly digest emails (every Monday at 9 AM)
 */
crons.cron(
  "weekly digest emails",
  "0 9 * * 1",
  internal.emails.sendWeeklyDigest
);

export default crons;
```

#### **Important Rules**
- **Only use `crons.interval()` or `crons.cron()`** - Do NOT use deprecated helpers like `crons.hourly()`, `crons.daily()`, or `crons.weekly()`
- **Pass function references, not functions** - Use `internal.module.function`, NOT the function itself
- **Only call internal functions** - Crons can only call `internalMutation`, `internalAction`, or `internalQuery`
- **Always export default** - The crons object must be the default export
- **Functions in same file need `internal`** - Even if registering functions in `crons.ts`, import them via `internal.crons.functionName`

#### **Example: Functions in Same File**
```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";

// Define internal function in same file
export const cleanupOldData = internalMutation({
  args: {},
  returns: v.null(),
  handler: async (ctx) => {
    const oldDate = Date.now() - 7 * 24 * 60 * 60 * 1000; // 7 days ago
    const oldItems = await ctx.db
      .query("items")
      .filter((q) => q.lt(q.field("createdAt"), oldDate))
      .collect();
    
    for (const item of oldItems) {
      await ctx.db.delete(item._id);
    }
    console.log(`Cleaned up ${oldItems.length} old items`);
    return null;
  },
});

const crons = cronJobs();

// Reference function from same file using internal
crons.interval(
  "cleanup old data",
  { hours: 24 },
  internal.crons.cleanupOldData
);

export default crons;
```

#### **Use Cases**
- **Cleanup tasks**: Remove old/expired data, fail stuck jobs
- **Scheduled reports**: Generate daily/weekly analytics
- **Data synchronization**: Sync with external services
- **Batch processing**: Process queued items periodically
- **Health monitoring**: Check system status regularly
- **Billing operations**: Monthly subscription processing
- **Email campaigns**: Send scheduled newsletters
- **Cache invalidation**: Clear expired cache entries

#### **Best Practices**
1. **Add descriptive names** - Use clear, action-oriented names like "cleanup old sessions" not "cleanup"
2. **Document purpose** - Add comments explaining what each cron does and why
3. **Use appropriate intervals** - Don't run expensive operations too frequently
4. **Monitor execution** - Check Convex Dashboard for failures or performance issues
5. **Handle errors gracefully** - Log errors and don't throw if failures are acceptable
6. **Keep operations idempotent** - Crons may occasionally run twice
7. **Use internal functions** - Never expose cron functions as public APIs
8. **Test with `npx convex run`** - Test internal functions manually before scheduling


## Client-side React guidelines
### Handling loading states with useQuery
- `useQuery` returns `undefined` while the subscription is being established or during initial load
- After loading, it returns the actual data (which could be an empty array/null/object)
- Be careful to distinguish between "loading" and "empty data" states to avoid UI flashing

#### Common pattern to avoid zero-state flash:
```typescript
// ❌ Bad - can show zero state briefly before data loads
const data = useQuery(api.myQuery) ?? [];
if (data.length === 0) {
  return <ZeroState />;
}

// ✅ Good - properly handles loading vs empty states
const data = useQuery(api.myQuery);
const isLoading = data === undefined;

if (isLoading) {
  return <LoadingSkeleton />;
}
if (data.length === 0) {
  return <ZeroState />;
}
```

#### For complex loading scenarios with state transitions:
```typescript
// When you need to track initial load completion
const [hasInitiallyLoaded, setHasInitiallyLoaded] = useState(false);
const data = useQuery(api.myQuery);

useEffect(() => {
  if (data !== undefined) {
    setHasInitiallyLoaded(true);
  }
}, [data]);

const isLoading = data === undefined || !hasInitiallyLoaded;
```

## File storage guidelines
- Convex includes file storage for large files like images, videos, and PDFs.
- The `ctx.storage.getUrl()` method returns a signed URL for a given file. It returns `null` if the file doesn't exist.
- **IMPORTANT**: `ctx.storage.getUrl()` is **only available server-side** in queries, mutations, and actions. There is **no client-side SDK method** to resolve storage IDs to URLs.
- Always resolve storage IDs to URLs within your Convex queries/mutations, then return the URLs to the client.
- Do NOT use the deprecated `ctx.storage.getMetadata` call for loading a file's metadata.

                    Instead, query the `_storage` system table. For example, you can use `ctx.db.system.get` to get an `Id<"_storage">`.
                    ```
                    import { query } from "./_generated/server";
                    import { Id } from "./_generated/dataModel";

                    type FileMetadata = {
                        _id: Id<"_storage">;
                        _creationTime: number;
                        contentType?: string;
                        sha256: string;
                        size: number;
                    }

                    export const exampleQuery = query({
                        args: { fileId: v.id("_storage") },
                        returns: v.null();
                        handler: async (ctx, args) => {
                            const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);
                            console.log(metadata);
                            return null;
                        },
                    });
                    ```
- Convex storage stores items as `Blob` objects. You must convert all items to/from a `Blob` when using Convex storage.

### Resolving storage URLs in queries
- When returning documents with storage IDs, resolve them to URLs server-side using `ctx.storage.getUrl()`.
- Use `Promise.all()` with `map()` to resolve multiple URLs efficiently:
                    ```typescript
                    import { query } from "./_generated/server";
                    import { v } from "convex/values";

                    export const getItems = query({
                        args: {},
                        returns: v.array(v.object({
                            _id: v.id("items"),
                            name: v.string(),
                            imageStorageId: v.optional(v.id("_storage")),
                            imageUrl: v.union(v.string(), v.null()),
                        })),
                        handler: async (ctx) => {
                            const items = await ctx.db.query("items").collect();

                            // Resolve storage IDs to URLs server-side
                            return Promise.all(
                                items.map(async (item) => ({
                                    _id: item._id,
                                    name: item.name,
                                    imageStorageId: item.imageStorageId,
                                    imageUrl: item.imageStorageId
                                        ? await ctx.storage.getUrl(item.imageStorageId)
                                        : null
                                }))
                            );
                        }
                    });
                    ```
- The client can then directly use the resolved URLs (e.g., in `<img>` tags or Next.js `Image` components).
- Do NOT attempt to construct storage URLs manually on the client or server - always use `ctx.storage.getUrl()`.


# Examples:
## Example: chat-app

### Task
```
Create a real-time chat application backend with AI responses. The app should:
- Allow creating users with names
- Support multiple chat channels
- Enable users to send messages to channels
- Automatically generate AI responses to user messages
- Show recent message history

The backend should provide APIs for:
1. User management (creation)
2. Channel management (creation)
3. Message operations (sending, listing)
4. AI response generation using OpenAI's GPT-4

Messages should be stored with their channel, author, and content. The system should maintain message order
and limit history display to the 10 most recent messages per channel.

```

### Analysis
1. Task Requirements Summary:
- Build a real-time chat backend with AI integration
- Support user creation
- Enable channel-based conversations
- Store and retrieve messages with proper ordering
- Generate AI responses automatically

2. Main Components Needed:
- Database tables: users, channels, messages
- Public APIs for user/channel management
- Message handling functions
- Internal AI response generation system
- Context loading for AI responses

3. Public API and Internal Functions Design:
Public Mutations:
- createUser:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({userId: v.id("users")})
  - purpose: Create a new user with a given name
- createChannel:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({channelId: v.id("channels")})
  - purpose: Create a new channel with a given name
- sendMessage:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), authorId: v.id("users"), content: v.string()}
  - returns: v.null()
  - purpose: Send a message to a channel and schedule a response from the AI

Public Queries:
- listMessages:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
    }))
  - purpose: List the 10 most recent messages from a channel in descending creation order

Internal Functions:
- generateResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.null()
  - purpose: Generate a response from the AI for a given channel
- loadContext:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }))
- writeAgentResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), content: v.string()}
  - returns: v.null()
  - purpose: Write an AI response to a given channel

4. Schema Design:
- users
  - validator: { name: v.string() }
  - indexes: <none>
- channels
  - validator: { name: v.string() }
  - indexes: <none>
- messages
  - validator: { channelId: v.id("channels"), authorId: v.optional(v.id("users")), content: v.string() }
  - indexes
    - by_channel: ["channelId"]

5. Background Processing:
- AI response generation runs asynchronously after each user message
- Uses OpenAI's GPT-4 to generate contextual responses
- Maintains conversation context using recent message history


### Implementation

#### package.json
```typescript
{
  "name": "chat-app",
  "description": "This example shows how to build a chat app without authentication.",
  "version": "1.0.0",
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0"
  },
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}
```

#### tsconfig.json
```typescript
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "exclude": ["convex"],
  "include": ["**/src/**/*.tsx", "**/src/**/*.ts", "vite.config.ts"]
}
```

#### convex/index.ts
```typescript
import {
  query,
  mutation,
  internalQuery,
  internalMutation,
  internalAction,
} from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { internal } from "./_generated/api";

/**
 * Create a user with a given name.
 */
export const createUser = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("users", { name: args.name });
  },
});

/**
 * Create a channel with a given name.
 */
export const createChannel = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("channels"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("channels", { name: args.name });
  },
});

/**
 * List the 10 most recent messages from a channel in descending creation order.
 */
export const listMessages = query({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      _id: v.id("messages"),
      _creationTime: v.number(),
      channelId: v.id("channels"),
      authorId: v.optional(v.id("users")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);
    return messages;
  },
});

/**
 * Send a message to a channel and schedule a response from the AI.
 */
export const sendMessage = mutation({
  args: {
    channelId: v.id("channels"),
    authorId: v.id("users"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const user = await ctx.db.get(args.authorId);
    if (!user) {
      throw new Error("User not found");
    }
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      authorId: args.authorId,
      content: args.content,
    });
    await ctx.scheduler.runAfter(0, internal.index.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

export const generateResponse = internalAction({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.index.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("No content in response");
    }
    await ctx.runMutation(internal.index.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = internalQuery({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.db.get(message.authorId);
        if (!user) {
          throw new Error("User not found");
        }
        result.push({
          role: "user" as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: "assistant" as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = internalMutation({
  args: {
    channelId: v.id("channels"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

#### convex/schema.ts
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),

  users: defineTable({
    name: v.string(),
  }),

  messages: defineTable({
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }).index("by_channel", ["channelId"]),
});
```

#### src/App.tsx
```typescript
export default function App() {
  return <div>Hello World</div>;
}
```

