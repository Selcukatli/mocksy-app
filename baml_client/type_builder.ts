/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    Avatar: ClassViewer<'Avatar', "summary" | "apparent_age" | "gender_presentation" | "ethnic_appearance" | "face_shape" | "jawline" | "body_build" | "skin_tone" | "complexion_details" | "hair_color" | "hair_length" | "hair_style" | "eye_color" | "eye_shape" | "eyebrows" | "nose_description" | "lip_description" | "facial_hair" | "glasses" | "glasses_style" | "distinctive_features" | "confidence" | "key_features">;
    
    Background: ClassViewer<'Background', "colors" | "effects" | "placement" | "seamless_to_bottom" | "forbidden">;
    
    BasicResponse: ClassViewer<'BasicResponse', "answer" | "confidence">;
    
    Character: ClassViewer<'Character', "name" | "avatar" | "outfit" | "expression" | "signature_colors">;
    
    CharacterInScene: ClassViewer<'CharacterInScene', "character_index" | "description" | "pose" | "placement" | "outfit_modifications" | "interaction">;
    
    Composition: ClassViewer<'Composition', "priority" | "rules">;
    
    DetailedResponse: ClassViewer<'DetailedResponse', "answer" | "confidence" | "explanation" | "sources">;
    
    DeviceSpec: ClassViewer<'DeviceSpec', "type" | "aspect_ratio" | "frame" | "angle" | "scale" | "position" | "screenshot">;
    
    FontStyle: ClassViewer<'FontStyle', "family" | "weight" | "color" | "effects">;
    
    HeaderText: ClassViewer<'HeaderText', "copy" | "placement" | "font" | "size">;
    
    LayoutConfig: ClassViewer<'LayoutConfig', "composition" | "device_orientation" | "device_type">;
    
    ModelTestResponse: ClassViewer<'ModelTestResponse', "model_name" | "response_text" | "character_count" | "passed">;
    
    Outfit: ClassViewer<'Outfit', "top" | "bottom" | "footwear" | "outerwear" | "accessories" | "style" | "color_scheme" | "fabric_textures">;
    
    PromptStructure: ClassViewer<'PromptStructure', "subjects" | "group_action" | "environment" | "style" | "technical" | "quality">;
    
    PromptStyle: ClassViewer<'PromptStyle', "art_style" | "color_palette" | "mood" | "lighting" | "texture">;
    
    PromptTechnical: ClassViewer<'PromptTechnical', "camera_angle" | "shot_type" | "composition" | "depth_of_field">;
    
    Scene: ClassViewer<'Scene', "main_description" | "characters" | "character_arrangement" | "camera_angle" | "shot_type" | "setting" | "background" | "time_of_day" | "mood" | "color_palette" | "lighting_style" | "style_keywords" | "quality_markers" | "main_prompt" | "negative_prompt" | "structured_prompt" | "suggested_guidance" | "complexity_score" | "avatar_integration" | "character_count" | "key_elements">;
    
    ScreenshotPromptStructured: ClassViewer<'ScreenshotPromptStructured', "style" | "background" | "device" | "header_text" | "composition">;
    
    ScreenshotTreatment: ClassViewer<'ScreenshotTreatment', "treatment" | "preserve" | "forbidden">;
    
    StyleConfig: ClassViewer<'StyleConfig', "background_color" | "details" | "text_style" | "device_style">;
    
    StyleGenerationOutput: ClassViewer<'StyleGenerationOutput', "style_config" | "device_reference_prompt" | "preview_image_prompt">;
    
    Subject: ClassViewer<'Subject', "description" | "action" | "position">;
    
    TextConfig: ClassViewer<'TextConfig', "header" | "subheader">;
    
    VisionTestResponse: ClassViewer<'VisionTestResponse', "model_name" | "can_see_image" | "description" | "object_count">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "Avatar","Background","BasicResponse","Character","CharacterInScene","Composition","DetailedResponse","DeviceSpec","FontStyle","HeaderText","LayoutConfig","ModelTestResponse","Outfit","PromptStructure","PromptStyle","PromptTechnical","Scene","ScreenshotPromptStructured","ScreenshotTreatment","StyleConfig","StyleGenerationOutput","Subject","TextConfig","VisionTestResponse",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.Avatar = this.tb.classViewer("Avatar", [
          "summary","apparent_age","gender_presentation","ethnic_appearance","face_shape","jawline","body_build","skin_tone","complexion_details","hair_color","hair_length","hair_style","eye_color","eye_shape","eyebrows","nose_description","lip_description","facial_hair","glasses","glasses_style","distinctive_features","confidence","key_features",
        ]);
        
        this.Background = this.tb.classViewer("Background", [
          "colors","effects","placement","seamless_to_bottom","forbidden",
        ]);
        
        this.BasicResponse = this.tb.classViewer("BasicResponse", [
          "answer","confidence",
        ]);
        
        this.Character = this.tb.classViewer("Character", [
          "name","avatar","outfit","expression","signature_colors",
        ]);
        
        this.CharacterInScene = this.tb.classViewer("CharacterInScene", [
          "character_index","description","pose","placement","outfit_modifications","interaction",
        ]);
        
        this.Composition = this.tb.classViewer("Composition", [
          "priority","rules",
        ]);
        
        this.DetailedResponse = this.tb.classViewer("DetailedResponse", [
          "answer","confidence","explanation","sources",
        ]);
        
        this.DeviceSpec = this.tb.classViewer("DeviceSpec", [
          "type","aspect_ratio","frame","angle","scale","position","screenshot",
        ]);
        
        this.FontStyle = this.tb.classViewer("FontStyle", [
          "family","weight","color","effects",
        ]);
        
        this.HeaderText = this.tb.classViewer("HeaderText", [
          "copy","placement","font","size",
        ]);
        
        this.LayoutConfig = this.tb.classViewer("LayoutConfig", [
          "composition","device_orientation","device_type",
        ]);
        
        this.ModelTestResponse = this.tb.classViewer("ModelTestResponse", [
          "model_name","response_text","character_count","passed",
        ]);
        
        this.Outfit = this.tb.classViewer("Outfit", [
          "top","bottom","footwear","outerwear","accessories","style","color_scheme","fabric_textures",
        ]);
        
        this.PromptStructure = this.tb.classViewer("PromptStructure", [
          "subjects","group_action","environment","style","technical","quality",
        ]);
        
        this.PromptStyle = this.tb.classViewer("PromptStyle", [
          "art_style","color_palette","mood","lighting","texture",
        ]);
        
        this.PromptTechnical = this.tb.classViewer("PromptTechnical", [
          "camera_angle","shot_type","composition","depth_of_field",
        ]);
        
        this.Scene = this.tb.classViewer("Scene", [
          "main_description","characters","character_arrangement","camera_angle","shot_type","setting","background","time_of_day","mood","color_palette","lighting_style","style_keywords","quality_markers","main_prompt","negative_prompt","structured_prompt","suggested_guidance","complexity_score","avatar_integration","character_count","key_elements",
        ]);
        
        this.ScreenshotPromptStructured = this.tb.classViewer("ScreenshotPromptStructured", [
          "style","background","device","header_text","composition",
        ]);
        
        this.ScreenshotTreatment = this.tb.classViewer("ScreenshotTreatment", [
          "treatment","preserve","forbidden",
        ]);
        
        this.StyleConfig = this.tb.classViewer("StyleConfig", [
          "background_color","details","text_style","device_style",
        ]);
        
        this.StyleGenerationOutput = this.tb.classViewer("StyleGenerationOutput", [
          "style_config","device_reference_prompt","preview_image_prompt",
        ]);
        
        this.Subject = this.tb.classViewer("Subject", [
          "description","action","position",
        ]);
        
        this.TextConfig = this.tb.classViewer("TextConfig", [
          "header","subheader",
        ]);
        
        this.VisionTestResponse = this.tb.classViewer("VisionTestResponse", [
          "model_name","can_see_image","description","object_count",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}